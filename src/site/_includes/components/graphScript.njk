<script>
    function adaptGraphData(raw) {
        if (!raw || !Array.isArray(raw.nodes) || !Array.isArray(raw.links)) return null;

        // Ensure ids are strings and consistent (we use url as id from /graph.json)
        const byId = {};
        for (const n of raw.nodes) {
            const id = String(n.id || n.url || "");
            byId[id] = {
                id,
                url: n.url || id,
                title: n.title || id,
                hide: !!n.hide,
                home: !!n.home,
                neighbors: []   // fill below
            };
        }

        // Normalize links to string ids and build neighbor lists
        const links = [];
        for (const l of raw.links) {
            const s = typeof l.source === "string" ? l.source : String(l.source?.id || l.source || "");
            const t = typeof l.target === "string" ? l.target : String(l.target?.id || l.target || "");
            if (byId[s] && byId[t]) {
                links.push({ source: s, target: t });
                byId[s].neighbors.push(t);
                byId[t].neighbors.push(s);
            }
        }

        return { nodes: byId, links };
    }

    async function fetchGraphData() {
        const raw = await fetch('/graph.json', { cache: 'no-store' }).then(res => res.json());
        const graphData = adaptGraphData(raw);          // <-- adapt here
        const fullGraphData  = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    }
    {# async function fetchGraphData() {
        const graphData = await fetch('/graph.json').then(res => res.json());
        const fullGraphData  = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    } #}

    {# function getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
                if (keys.indexOf(key) != -1) {
                    if (!remaining[key].hide) {
                        existing[key] = remaining[key];
                    }
                } else {
                    acc[key] = remaining[key];
                }
                return acc;
            }, {});
        return existing, n_remaining;
    } #}

    function getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
            if (keys.indexOf(key) !== -1) {
                if (!remaining[key].hide) {
                    existing[key] = remaining[key];
                }
            } else {
                acc[key] = remaining[key];
            }
            return acc;
        }, {});
        return [existing, n_remaining]; // return a pair
    }

    function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            return null;
        }
        let remaining = JSON.parse(JSON.stringify(graphData.nodes));
        let links = JSON.parse(JSON.stringify(graphData.links));
        let currentLink = decodeURI(window.location.pathname);
        let currentNode = remaining[currentLink] || Object.values(remaining).find((v) => v.home);
        delete remaining[currentNode.url];
        if (!currentNode.home) {
            let home = Object.values(remaining).find((v) => v.home);
            delete remaining[home.url];
        }
        currentNode.current = true;
        let existing = {};
        existing[currentNode.url] = currentNode;
        for (let i = 0; i < depth; i++) {
        [existing, remaining] = getNextLevelNeighbours(existing, remaining);
        }
        nodes = Object.values(existing);
        if (!currentNode.home) {
            nodes = nodes.filter(n => !n.home);
        }
        let ids = nodes.map((n) => n.id);
        return {
            nodes,
            links: links.filter(function (con) {
                return ids.indexOf(con.target) > -1 && ids.indexOf(con.source) > -1;
            }),
        }
    }

    function getCssVar(variable) {return getComputedStyle(document.body).getPropertyValue(variable)}

    function htmlDecode(input) {
        var doc = new DOMParser().parseFromString(input, "text/html");
        return doc.documentElement.textContent;
    }

    function renderGraph(graphData, id, delay, fullScreen) {
        if (!graphData || !Array.isArray(graphData.nodes)) return null;

        const el = document.getElementById(id);
        if (!el || el.nodeType !== 1) {
            console.warn("graph: container missing:", id);
            return null;
        }
        if (typeof ForceGraph !== "function") {
            console.warn("graph: ForceGraph not loaded yet");
            return null;
        }

        const width = el.offsetWidth || el.clientWidth || 600;
        const height = el.offsetHeight || el.clientHeight || 400;

        const highlightNodes = new Set();
        let hoverNode = null;
        const color = getCssVar("--graph-main");
        const mutedColor = getCssVar("--graph-muted");

        const Graph = ForceGraph()(el)
            .graphData(graphData)
            .nodeId('id')
            .nodeLabel('title')
            .linkSource('source')
            .linkTarget('target')
            .d3AlphaDecay(0.10)
            .width(width)
            .height(height)
            .linkDirectionalArrowLength(2)
            .linkDirectionalArrowRelPos(0.5)
            .autoPauseRedraw(false)
            .linkColor((link) => {
                if (hoverNode == null) {
                    return color;
                }
                if (link.source.id == hoverNode.id || link.target.id == hoverNode.id) {
                    return color;
                } else {
                    return mutedColor;
                }
                
            })
            .nodeCanvasObject((node, ctx) => {
                const numberOfNeighbours = (node.neighbors && node.neighbors.length) || 2;
                const nodeR = Math.min(7, Math.max(numberOfNeighbours / 2, 2));
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeR, 0, 2 * Math.PI, false);
                if (hoverNode == null) {
                    ctx.fillStyle = color;
                } else {
                    if (node == hoverNode || highlightNodes.has(node.url)) {
                        ctx.fillStyle = color;
                    } else {
                        ctx.fillStyle = mutedColor;
                    }
                }
                 
                ctx.fill();
                
                if (node.current) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeR + 1, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = color;
                    ctx.stroke();
                }

                const label = htmlDecode(node.title)
                const fontSize = 3.5;
                ctx.font = `${fontSize}px Sans-Serif`;

                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(label, node.x, node.y + nodeR + 2);
            })
            .onNodeClick(node => {
                window.location = node.url;
            })
            .onNodeHover(node => {
                highlightNodes.clear();
                if (node) {
                highlightNodes.add(node);
                node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                }
                hoverNode = node || null;
                
            });
            if (fullScreen || (delay != null && graphData.nodes.length > 4)) {
                setTimeout(() => {
                    Graph.zoomToFit(5, 75);
                }, delay || 200);
            }
        return Graph;
    }

    function renderLocalGraph(graphData, depth, fullScreen, currentNode) {
      if (window.graph) { window.graph._destructor?.(); }
      const data = filterLocalGraphData(graphData, depth, currentNode);
      return renderGraph(data, 'link-graph', null, fullScreen);
    }

    function filterFullGraphData(graphData) {
        if (graphData == null) {
            return null;
        }
        graphData = JSON.parse(JSON.stringify(graphData));
        const hiddens = Object.values(graphData.nodes).filter((n) => n.hide).map((n) => n.id);
        const data = {
            links: JSON.parse(JSON.stringify(graphData.links)).filter((l) => hiddens.indexOf(l.source) == -1 && hiddens.indexOf(l.target) == -1),
            nodes: [...Object.values(graphData.nodes).filter((n) => !n.hide)]
        }
        return data
    }

    function openFullGraph(fullGraphData) {
        lucide.createIcons({
                attrs: {
                    class: ["svg-icon"]
                }
            });
        return renderGraph(fullGraphData, "full-graph-container", 200, false);;
    }

    function closefullGraph(fullGraph) {
        if (fullGraph) {
            fullGraph._destructor();
        }
        return null;
    }

  // Fallback finder: current URL -> seed url -> first node
  function safeCurrentNode(fullGraph) {
    const trim = p => (p || '').replace(/\/+$/,'') || '/';
    const here = trim(window.location.pathname);
    const byUrl = fullGraph?.nodes?.find(n => trim(n.url) === here);
    if (byUrl) return byUrl;

    const seed = document.getElementById('graph-component')?.dataset?.seedUrl;
    if (seed) {
      const bySeed = fullGraph?.nodes?.find(n => trim(n.url) === trim(seed));
      if (bySeed) return bySeed;
    }
    return fullGraph?.nodes?.[0] || null;
  }

  // Add a null-guard at the top of your existing filter function
  function filterLocalGraphData(data, depth, currentNode) {
    if (!data || !data.nodes || !data.links) return { nodes: [], links: [] };
    if (!currentNode) {
      // no current note (e.g., homepage): show full graph
      return { nodes: Object.values(data.nodes), links: data.links };
    }

    let remaining = JSON.parse(JSON.stringify(data.nodes));
    let links = JSON.parse(JSON.stringify(data.links));

    // resolve the provided current node against our map
    const node = remaining[currentNode.id] || Object.values(remaining).find(n => n.url === currentNode.url);
    if (!node) return { nodes: Object.values(remaining), links };

    delete remaining[node.url];
    if (!node.home) {
      const home = Object.values(remaining).find(v => v.home);
      if (home) delete remaining[home.url];
    }

    node.current = true;
    let existing = { [node.url]: node };
    for (let i = 0; i < depth; i++) {
      [existing, remaining] = getNextLevelNeighbours(existing, remaining);
    }

    let nodes = Object.values(existing);
    if (!node.home) nodes = nodes.filter(n => !n.home);
    const ids = nodes.map(n => n.id);
    return {
      nodes,
      links: links.filter(con => ids.includes(con.target) && ids.includes(con.source)),
    };
  }
</script>
<div
  x-data="{ graphData: null, depth: 1, graph: null, fullGraph: null, showFullGraph: false, fullScreen: false, fullGraphData: null, currentNode: null }"
  id="graph-component"
  data-seed-url="{{ (collections.zettels | default([]) | first).url | default('') }}"
  x-init="
    ({ graphData, fullGraphData } = await fetchGraphData());
    fullGraph = fullGraphData;
    currentNode = safeCurrentNode(fullGraphData);
  "
  x-effect="$nextTick(() => { window.graph = renderLocalGraph(graphData, depth, fullScreen, currentNode) })"
  x-bind:class="fullScreen ? 'graph graph-fs' : 'graph'">
    <div class="graph-title-container">
        <div class="graph-title">Connected Pages</div>
        <div id="graph-controls">
                <div class="depth-control">
                    <label for="graph-depth">Depth</label>
                    <div class="slider">
                            <input x-model.number="depth" name="graph-depth" list="depthmarkers" type="range" step="1" min="1" max="3" id="graph-depth"/>
                    <datalist id="depthmarkers">
                            <option value="1" label="1"></option>
                            <option value="2" label="2"></option>
                            <option value="3" label="3"></option>
                    </datalist>
                    </div>
                    <span id="depth-display" x-text="depth"></span>
                </div>
                <div class="ctrl-right">
                    <span id="global-graph-btn" x-on:click="showFullGraph = true; setTimeout(() => {fullGraph = openFullGraph(fullGraphData)}, 100)"><i  icon-name="globe" aria-hidden="true"></i></span>
                    <span  id="graph-fs-btn"  x-on:click="fullScreen = !fullScreen"><i  icon-name="expand" aria-hidden="true"></i></span>
                </div>
        </div>
    </div>
    <div x-effect="window.graph = renderLocalGraph(graphData, depth, fullScreen)" id="link-graph" ></div>
    <div x-show="showFullGraph" id="full-graph" class="show" style="display: none;">
        <span id="full-graph-close" x-on:click="fullGraph = closefullGraph(fullGraph); showFullGraph = false;"><i icon-name="x" aria-hidden="true"></i></span><div id="full-graph-container"></div>
    </div>
</div>
<script>
(async function () {
  const el = document.getElementById("graph");
  if (!el) return;
  if (typeof ForceGraph !== "function") return;

  try {
    const res = await fetch("{{ '/graph.json' | url }}", { cache: "no-store" });
    if (!res.ok) throw new Error(res.statusText);
    const data = await res.json();

    // clean previous instance if any
    if (window.graph && window.graph._destructor) window.graph._destructor();

    const Graph = ForceGraph()(el)
      .graphData(data)
      .nodeId("id")
      .nodeLabel("title")
      .linkSource("source")
      .linkTarget("target")
      .width(el.clientWidth)
      .height(el.clientHeight);

    window.graph = Graph;
  } catch (e) {
    console.warn("graph init failed:", e);
  }
})();
</script>