<script>
    function adaptGraphData(raw) {
        if (!raw || !Array.isArray(raw.nodes) || !Array.isArray(raw.links)) return null;

        // Ensure ids are strings and consistent (we use url as id from /graph.json)
        const byId = {};
        for (const n of raw.nodes) {
            const id = String(n.id || n.url || "");
            byId[id] = {
                id,
                url: n.url || id,
                title: n.title || id,
                hide: !!n.hide,
                home: !!n.home,
                neighbors: []   // fill below
            };
        }

        // Normalize links to string ids and build neighbor lists
        const links = [];
        for (const l of raw.links) {
            const s = typeof l.source === "string" ? l.source : String(l.source?.id || l.source || "");
            const t = typeof l.target === "string" ? l.target : String(l.target?.id || l.target || "");
            if (byId[s] && byId[t]) {
                links.push({ source: s, target: t });
                byId[s].neighbors.push(t);
                byId[t].neighbors.push(s);
            }
        }

        return { nodes: byId, links };
    }

    {# async function fetchGraphData() {
        const raw = await {{ '/graph.json' | url }}, { cache: 'no-store' }).then(res => res.json());
        const graphData = adaptGraphData(raw);          // <-- adapt here
        const fullGraphData  = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    } #}
    {# async function fetchGraphData() {
        const graphData = await fetch('/graph.json').then(res => res.json());
        const fullGraphData  = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    } #}

    {# function getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
                if (keys.indexOf(key) != -1) {
                    if (!remaining[key].hide) {
                        existing[key] = remaining[key];
                    }
                } else {
                    acc[key] = remaining[key];
                }
                return acc;
            }, {});
        return existing, n_remaining;
    } #}

    function getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
            if (keys.indexOf(key) !== -1) {
                if (!remaining[key].hide) {
                    existing[key] = remaining[key];
                }
            } else {
                acc[key] = remaining[key];
            }
            return acc;
        }, {});
        return [existing, n_remaining]; // return a pair
    }

    {# function filterLocalGraphData(data, depth, currentNode) {
      if (!data || !data.nodes || !data.links) return { nodes: [], links: [] };
      if (!currentNode) {
        // No current page match (e.g., homepage) -> show full graph
        return { nodes: Object.values(data.nodes), links: data.links };
      }
      let remaining = JSON.parse(JSON.stringify(data.nodes));
      let links = JSON.parse(JSON.stringify(data.links));
      let currentLink = decodeURI(window.location.pathname);
      let currentNodeData = remaining[currentLink] || Object.values(remaining).find((v) => v.home);
      delete remaining[currentNodeData.url];
      if (!currentNodeData.home) {
          let home = Object.values(remaining).find((v) => v.home);
          delete remaining[home.url];
      }
      currentNodeData.current = true;
      let existing = {};
      existing[currentNodeData.url] = currentNodeData;
      for (let i = 0; i < depth; i++) {
      [existing, remaining] = getNextLevelNeighbours(existing, remaining);
      }
      nodes = Object.values(existing);
      if (!currentNodeData.home) {
          nodes = nodes.filter(n => !n.home);
      }
      let ids = nodes.map((n) => n.id);
      return {
          nodes,
          links: links.filter(function (con) {
              return ids.indexOf(con.target) > -1 && ids.indexOf(con.source) > -1;
          }),
      }
    } #}

    function getCssVar(variable) {return getComputedStyle(document.body).getPropertyValue(variable)}

    function htmlDecode(input) {
        var doc = new DOMParser().parseFromString(input, "text/html");
        return doc.documentElement.textContent;
    }

    function renderGraph(graphData, id, fullScreen) {
        if (!graphData || !Array.isArray(graphData.nodes)) return null;
        const el = document.getElementById(id);
        if (!el) { console.warn('graph: container missing', id); return null; }
        if (typeof ForceGraph !== 'function') { console.warn('graph: ForceGraph not loaded'); return null; }

        const width = el.offsetWidth || 600;
        const height = el.offsetHeight || 400;

        const Graph = ForceGraph()(el)
            .graphData(graphData)
            .nodeId('id')
            .nodeLabel('title')
            .linkSource('source')
            .linkTarget('target')
            .width(width)
            .height(height);

        return Graph;
    }
</script>

<script>
// homepage bootstrap (optional, safe)
{# (async function () {
  const id = pickGraphContainerId();
  if (!id) return;
  if (typeof ForceGraph !== "function") return;
  try {
    const res = await fetch("{{ '/graph.json' | url }}", { cache: "no-store" });
    if (!res.ok) return;
    const data = await res.json();
    if (window.graph && window.graph._destructor) window.graph._destructor();
    window.graph = renderGraph(data, id, false);
  } catch (e) { console.warn('graph init failed', e); }
})(); #}
</script>

<script>
(function () {
  // Pick container (note pages or homepage)
  const pickContainerId = () => {
    if (document.getElementById("link-graph")) return "link-graph";
    if (document.getElementById("graph")) return "graph";
    return null;
  };
  // Back-compat alias for any old code
  const pickGraphContainerId = pickContainerId;

  const cssVar = (name, fb) => {
    try { const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim(); return v || fb; }
    catch { return fb; }
  };
  const COLORS = {
    main:  cssVar("--graph-main",  "#7aa2f7"),
    muted: cssVar("--graph-muted", "#9aa5ce"),
    curr:  cssVar("--text-accent", "#f7768e"),
    link:  cssVar("--graph-link",  "rgba(154,165,206,0.55)"),
    labelBg:   cssVar("--graph-label-bg",   "rgba(0,0,0,0.55)"),
    labelText: cssVar("--graph-label-text", "#fff")
  };

  const norm = p => (String(p || "").replace(/\/+$/,"") || "/");
  const sameUrl = (a, b) => norm(a) === norm(b);

  async function fetchGraph() {
    const res = await fetch("{{ '/graph.json' | url }}", { cache: "no-store" }); // <-- quoted + fetch()
    if (!res.ok) throw new Error(`graph.json ${res.status}`);
    return res.json();
  }

  function adapt(raw) {
    if (!raw || !Array.isArray(raw.nodes) || !Array.isArray(raw.links)) {
      return { nodes: [], links: [], adj: new Map() };
    }
    const idOf = n => String(n.id || n.url || "");
    const nodes = raw.nodes.map(n => ({
      id: idOf(n),
      url: n.url || idOf(n),
      title: n.title || idOf(n),
      home: !!n.home
    }));
    const adj = new Map(nodes.map(n => [n.id, new Set()]));
    const links = [];
    for (const l of raw.links) {
      const s = typeof l.source === "string" ? l.source : String(l.source?.id || l.source || "");
      const t = typeof l.target === "string" ? l.target : String(l.target?.id || l.target || "");
      if (adj.has(s) && adj.has(t)) {
        links.push({ source: s, target: t });
        adj.get(s).add(t); adj.get(t).add(s);
      }
    }
    return { nodes, links, adj };
  }

  function neighborhood(data, currentId, depth) {
    if (!currentId || depth <= 0) return { nodes: data.nodes, links: data.links };
    const visited = new Set([currentId]);
    let frontier = [currentId];
    for (let d = 0; d < depth; d++) {
      const next = [];
      for (const id of frontier) {
        for (const nb of (data.adj.get(id) || [])) {
          if (!visited.has(nb)) { visited.add(nb); next.push(nb); }
        }
      }
      frontier = next;
    }
    const nodes = data.nodes.filter(n => visited.has(n.id));
    const links = data.links.filter(l => visited.has(l.source) && visited.has(l.target));
    return { nodes, links };
  }

  function currentFromPath(nodes) {
    const here = norm(window.location.pathname);
    return nodes.find(n => sameUrl(n.url, here)) || null;
  }

  function render(elId, data, current, depth) {
    const el = document.getElementById(elId);
    if (!el || typeof ForceGraph !== "function") return null;

    const subset = current ? neighborhood(data, current.id, depth) : { nodes: data.nodes, links: data.links };
    const width = el.offsetWidth || 600;
    const height = el.offsetHeight || 400;

    const highlightNodes = new Set();
    const highlightLinks = new Set();

    const graph = ForceGraph()(el)
      .graphData(subset)
      .nodeId("id")
      .nodeLabel("title")
      .linkSource("source")
      .linkTarget("target")
      .width(width)
      .height(height)
      .d3AlphaDecay(0.1)
      .nodeRelSize(4)
      .linkDirectionalArrowLength(0)
      .backgroundColor(null)
      .onNodeHover(node => {
        highlightNodes.clear();
        highlightLinks.clear();
        if (node) {
          highlightNodes.add(node.id);
          (data.adj.get(node.id) || []).forEach(nid => highlightNodes.add(nid));
          data.links.forEach(l => {
            if (l.source === node.id || l.target === node.id) highlightLinks.add(l);
          });
        }
        el.style.cursor = node ? "pointer" : null;
      })
      .onNodeClick(node => { if (node?.url) window.location.href = node.url; })
      .nodeColor(n => (current && n.id === current.id) ? COLORS.curr : (highlightNodes.has(n.id) ? COLORS.main : COLORS.muted))
      .linkColor(l => (highlightLinks.has(l) ? COLORS.main : COLORS.link))
      .linkWidth(l => (highlightLinks.has(l) ? 2.2 : 0.8))
      // Draw labels with DG theme colors
      .nodeCanvasObject((node, ctx, globalScale) => {
        // Optional zoom gate: comment out to always show labels
        if (12 / globalScale < 6) return;

        const label = node.title || node.id;
        if (!label) return;

        const isCurrent = current && node.id === current.id;
        const color = isCurrent ? cssVar("--text-accent", "#f7768e")
                                : cssVar("--graph-label-text", "#ffffff");

        const fontSize = Math.max(8, 12 / globalScale);
        ctx.font = `${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Fill text
        ctx.fillStyle = color;
        ctx.fillText(label, node.x, node.y);
      })
      .nodeCanvasObjectMode(() => "after");

    const ro = new ResizeObserver(() => {
      graph.width(el.offsetWidth || 600).height(el.offsetHeight || 400);
    });
    ro.observe(el);
    return graph;
  }

  async function init() {
    const id = pickContainerId();
    if (!id) return;
    const raw = await fetchGraph();
    const data = adapt(raw);
    const current = currentFromPath(data.nodes);
    if (window.graph && window.graph._destructor) window.graph._destructor();
    window.graph = render(id, data, current, 2);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => init().catch(console.warn));
  } else {
    init().catch(console.warn);
  }
})();
</script>
