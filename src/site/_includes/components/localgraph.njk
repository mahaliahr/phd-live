<div
  x-data="{ graphData: null, depth: 1, graph: null, fullGraph: null, showFullGraph: false, fullScreen: false, fullGraphData: null }"
  x-init="(async () => { const r = await fetchGraphData(); graphData = r.graphData; fullGraphData = r.fullGraphData; })()"
  id="graph-component"
  x-bind:class="fullScreen ? 'graph graph-fs' : 'graph'">
    <div class="graph-title-container">
      ...
    </div>
    <div x-effect="if (graphData) { window.graph = renderLocalGraph(graphData, depth, fullScreen); }" id="link-graph"></div>
    <div x-show="showFullGraph" id="full-graph" class="show" style="display:none;">
      ...
    </div>
</div>

<script>
window.localGraph = window.localGraph || function localGraph() {
  const cssVar = (name, fb) => {
    try { const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim(); return v || fb; }
    catch { return fb; }
  };
  const COLORS = {
    main:  cssVar("--graph-main",  "#7aa2f7"),
    muted: cssVar("--graph-muted", "#9aa5ce"),
    curr:  cssVar("--text-accent", "#f7768e"),
    link:  cssVar("--graph-link",  "rgba(154,165,206,0.55)"),
    label: cssVar("--graph-label-text", "rgba(154,165,206,0.55)")
  };
  const norm = p => (String(p || "").replace(/\/+$/,"") || "/");
  const sameUrl = (a, b) => norm(a) === norm(b);

  return {
    fg: null,
    data: { nodes: [], links: [], adj: new Map() },
    current: null,
    depth: 2,
    showAll: false,
    isFullscreen: false,

    async init() {
      if (typeof ForceGraph !== "function") return;
      const canvas = this.$refs?.canvas;
      if (!canvas) return;

      try {
        const raw = await fetch("{{ '/graph.json' | url }}", { cache: "no-store" }).then(r => r.json());
        this.data = this.adapt(raw);
      } catch { this.data = { nodes: [], links: [], adj: new Map() }; }

      this.current = this.currentFromPath(this.data.nodes);
      this.showAll = !this.current;

      this.fg = this.createGraph(canvas);
      this.applySubset();

      const sizeToEl = () => {
        try {
          const w = Math.max(1, canvas.offsetWidth);
          const h = Math.max(1, canvas.offsetHeight);
          this.fg.width(w).height(h);
        } catch {}
      };
      sizeToEl();

      try {
        const ro = new ResizeObserver(sizeToEl);
        ro.observe(canvas);
      } catch {}

      // Ensure resize after any class toggles
      requestAnimationFrame(sizeToEl);
      requestAnimationFrame(sizeToEl);
    },

    adapt(raw) {
      if (!raw) return { nodes: [], links: [], adj: new Map() };

      // Case A: array shape { nodes: [...], links: [...] }
      if (Array.isArray(raw.nodes) && Array.isArray(raw.links)) {
        const idOf = n => String(n.id || n.url || "");
        const nodes = raw.nodes.map(n => ({ id: idOf(n), url: n.url || idOf(n), title: n.title || idOf(n) }));
        const adj = new Map(nodes.map(n => [n.id, new Set()]));
        const links = [];
        for (const l of raw.links) {
          const s = typeof l.source === "string" ? l.source : String(l.source?.id || l.source || "");
          const t = typeof l.target === "string" ? l.target : String(l.target?.id || l.target || "");
          if (adj.has(s) && adj.has(t)) { links.push({ source: s, target: t }); adj.get(s).add(t); adj.get(t).add(s); }
        }
        return { nodes, links, adj };
      }

      // Case B: DG map shape { nodes: { [url]: { title, linksTo:[], backLinks:[] } } }
      if (raw.nodes && !Array.isArray(raw.nodes)) {
        const entries = Object.entries(raw.nodes);
        const nodes = entries.map(([url, n]) => ({
          id: String(url),
          url: String(url),
          title: n?.title || String(url)
        }));
        const idSet = new Set(nodes.map(n => n.id));
        const adj = new Map(nodes.map(n => [n.id, new Set()]));
        const links = [];
        for (const [url, n] of entries) {
          const from = String(url);
          const toList = Array.isArray(n?.linksTo) ? n.linksTo : [];
          for (const to of toList) {
            const target = String(to);
            if (idSet.has(from) && idSet.has(target)) {
              links.push({ source: from, target });
              adj.get(from).add(target);
              adj.get(target).add(from);
            }
          }
        }
        return { nodes, links, adj };
      }

      return { nodes: [], links: [], adj: new Map() };
    },

    currentFromPath(nodes) {
      const here = norm(window.location.pathname);
      return (nodes || []).find(n => sameUrl(n.url, here)) || null;
    },

    neighborhood(currentId, depth) {
      if (!currentId || depth <= 0) return { nodes: this.data.nodes, links: this.data.links };
      const visited = new Set([currentId]); let frontier = [currentId];
      for (let d = 0; d < depth; d++) {
        const next = [];
        for (const id of frontier) for (const nb of (this.data.adj.get(id) || []))
          if (!visited.has(nb)) { visited.add(nb); next.push(nb); }
        frontier = next;
      }
      return {
        nodes: this.data.nodes.filter(n => visited.has(n.id)),
        links: this.data.links.filter(l => visited.has(l.source) && visited.has(l.target))
      };
    },

    createGraph(container) {
      const graph = ForceGraph()(container)
        .nodeId("id").nodeLabel("title").linkSource("source").linkTarget("target")
        .d3AlphaDecay(0.1).nodeRelSize(4).linkDirectionalArrowLength(0).backgroundColor(null)
        .onNodeClick(node => { if (node?.url) window.location.href = node.url; })
        .nodeColor(n => {
          const isCurrent = this.current && n.id === this.current.id;
          return isCurrent ? COLORS.curr : COLORS.muted;
        })
        .linkColor(() => COLORS.link)
        .linkWidth(() => 0.8)
        .nodeCanvasObject((node, ctx, globalScale) => {
          if (12 / globalScale < 6) return;
          const label = node.title || node.id; if (!label) return;
          const fontSize = Math.max(8, 12 / globalScale);
          ctx.font = `${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = COLORS.label;
          ctx.fillText(label, node.x, node.y);
        })
        .nodeCanvasObjectMode(() => "after");

      graph.width(container.offsetWidth || 600).height(container.offsetHeight || 360);
      return graph;
    },

    applySubset() {
      if (!this.fg) return;
      const subset = (this.showAll || !this.current)
        ? { nodes: this.data.nodes, links: this.data.links }
        : this.neighborhood(this.current.id, this.depth);
      this.fg.graphData(subset);
    },

    toggleAll() { this.showAll = !this.showAll; this.applySubset(); },
    fit() { try { this.fg.zoomToFit(500, 30); } catch {} },

    toggleFullscreen() {
      this.isFullscreen = !this.isFullscreen;
      this.$refs.canvas.classList.toggle("graph-fs", this.isFullscreen);
      document.body.classList.toggle("graph-fs-open", this.isFullscreen);
      // resize after layout change
      requestAnimationFrame(() => {
        try {
          const w = Math.max(1, this.$refs.canvas.offsetWidth);
          const h = Math.max(1, this.$refs.canvas.offsetHeight);
          this.fg.width(w).height(h);
          if (this.isFullscreen && typeof this.fg.zoomToFit === "function") this.fg.zoomToFit(400, 30);
        } catch {}
      });
    }
  };
};
</script>
{# {% include "components/graphScript.njk" %} #}